# ARG may precede 
# 好像没啥用，用在FROM语句里面的变量
# set the base image
FROM ubuntu AS something

# ARG

# docker build
# docker build command builds an image from a Dockerfile and a `context`
# The build's context is the set of a specified location `PATH` or `URL`
# The PATH is a directory on your local filesystem
# the URL is a Git repository location
# PATH and URL is processes recursively
# such as `docker build .` use pwd as the build context, it will find `Dockerfile` in its subdir

# context/files - docker cli -> docker daemon

# exclude files and directories by adding a `.dockerignore`

# docker build -f Dockerfile
# docker build -t new-image-tag -t multi-tags -f Dockerfile

# the docker daemon runs the instruction in the Dockerfile `one-by-one` 
# each instruction cause a new image
# so RUN cd /tmp will have no effect on the next layer

# comment lines are removed before the Dockerfile trans to the docker daemon


# Environment replacement
# ENV key=value ...
ENV FOO=/bar
# This value will be in the environment for all subsequent instructions in the build stage
# the environment variables set using ENV will persist
# when a container is run from the resulting image
# you can change them using docker run --env key=value

# want to Dockferfile local ENV, use ARG?

WORKDIR ${FOO}

# RUN <command> : /bin/sh -c 
# RUN ["executable", "xxx"] : exec
# the second way is better, 
# default shell form can be changed using the SHELL commands
# first build a base ssh image
RUN apt update && apt install -y \
    openssh-server \
    gcc \
 && apt clean
# the cache of the RUN will be reused during the next build
# docker build --no-cache will discard it

# CMD
# CMD []
# CMD command
# there can only be one CMD instruction in a Dockerfile
# The main purpose of a CMD is to provide defaults for an executing container.
# if user specifies arguments to docker run,
# they will override the default specified in CMD

# ENTRYPOINT

# LABEL 这个玩意有啥用 没看出来啊

# EXPOSE
EXPOSE 22/tcp 233/udp
# docker run -p -P
# Regardless of the EXPOSE settings
# you can override them at runtime by using the -p flag

# ADD
# ADD [--chown=<user>:<group>] <src>... <dest>
# ADD [--chown=<user>:<group>] ["<src>",... "<dest>"]
# src is relative to the source of the context of the build
# dest is an absolute path, or relative to WORKDIR
# all new files and dirs are created with a uid and gid of o(root)
# unless --chown
# if dest is a dir, must end with a /
# otherwise, it will be tteat as regular file
# file will be auto unpacked and uncompressed

# COPY

# ENTRYPOINT
# exec form & shell form
# exec form is better, just check the doc
# An ENTRYPOINT allows you to configure a container that will run as an executable.
# docker run image <cmd> will override the CMD, 
# the executable will run like `ENTRYPOINT CMD`
# you can use docker run --entrypoint to override ENTRYPOINT

# many daemon if you want to use it in docker
# you must run it in FOREGROUND mode

# `docker top container` can check the container's processes

# if CMD is defined from the base image, 
# setting ENTRYPOINT will reset CMD to an empty value

# Volume
VOLUME [ "/data" ]
# creates a mount point, json array
# the `docker run` command initializes the newly created
# volume with any data that exists at the specified location
# with the base image
FROM ubunt
RUN mkdir /myvol
RUN echo "hello world" > /myvol/greeting
VOLUME [ "/myvol" ]
# then when you run this image, and mount a host dir to the volumn
# it will create a new file in that dir called greeting
# if any build steps change the data within the volume
# after it has been declared
# those changes will be discard

# the host directory is declared at container run-time

# USER
USER zhangzhong:zhangzhonggroup
# USER <user>[:<group>]
# USER <UID>[:<GID>]
# the user instruction sets the user name ,group
# when runnign the image
# for any RUN CMD ENTRYPOINT instructions 
# that follow it in the Dockerfile
# if not set group, the user will belong to root group
# 那么如果不设置user，那些命令都是用root跑的

# WORKDIR
WORKDIR /the/workdir/path
# the WORKDIR sets the working directory for any
# RUN CMD ENTRYPOINT COPY ADD that follow it in the Dockerfile
# WORKDIR will be created auto


# ARG
ARG name=default_value
# the ARG instruction defines a variable that user
# can pass at `build-time` to the builder with the
# docker build command using the --build-arg name=value
# 
# an ARG variable definition comes into effect from the line on which it is defined in the Dockerfile
# an ARG instruction goes out of scope at the end of build stage
# compare to ENV
# but what is a build stage? a commit layer? every RUN COPY ADD etc. ??
# 
# env var always override the arg var of the same name
# 

# ONBUILD <INSTRUCTION>
# when the image is used as the base image for another build
# the instruction will be executed immediately after the FROM instruction
# in the downstream build abtou downstream Dockerfile
#
# any build instruction can be registered as a trigger
# 

# STOPSIGNAL
# 

# HEALTHCHECK
# 

# SHELL
# 

## Best practices
# multi-stage builds: order layers from the less frequency changed to the more frequency changed
# do not install unnecessary packages
# each container should have only one concern
# build cache
# minimize the number of layers
# only RUN COPY ADD create layers

# 容器化开发 containerize-development

# 如果一个状态仅应该在一层中有用，那么这些指令都应该属于同一层
# COPY is better, COPY files one by one, and use it immediately
# make sure your application is PID 1, use docker -it exec ps aux
# use exec form

# VOLUME should be used to expose any database storage area, configuration storage
# file/folders created by your docker contaienr, user data etc.
# sudo can cause problems. if you need sudo , consider using "gosu"
# WORKDIR alyways use absolute path
# 
